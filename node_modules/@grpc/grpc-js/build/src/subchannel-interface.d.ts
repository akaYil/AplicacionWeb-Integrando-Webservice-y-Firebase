<<<<<<< HEAD
import type { SubchannelRef } from './channelz';
import { ConnectivityState } from './connectivity-state';
import { Subchannel } from './subchannel';
export type ConnectivityStateListener = (subchannel: SubchannelInterface, previousState: ConnectivityState, newState: ConnectivityState, keepaliveTime: number, errorMessage?: string) => void;
export type HealthListener = (healthy: boolean) => void;
=======
import { SubchannelRef } from './channelz';
import { ConnectivityState } from './connectivity-state';
import { Subchannel } from './subchannel';
export type ConnectivityStateListener = (subchannel: SubchannelInterface, previousState: ConnectivityState, newState: ConnectivityState, keepaliveTime: number, errorMessage?: string) => void;
>>>>>>> ef326e5cf5f78addbb22f4e968c863fa7a1af5f4
/**
 * This is an interface for load balancing policies to use to interact with
 * subchannels. This allows load balancing policies to wrap and unwrap
 * subchannels.
 *
 * Any load balancing policy that wraps subchannels must unwrap the subchannel
 * in the picker, so that other load balancing policies consistently have
 * access to their own wrapper objects.
 */
export interface SubchannelInterface {
    getConnectivityState(): ConnectivityState;
    addConnectivityStateListener(listener: ConnectivityStateListener): void;
    removeConnectivityStateListener(listener: ConnectivityStateListener): void;
    startConnecting(): void;
    getAddress(): string;
    throttleKeepalive(newKeepaliveTime: number): void;
    ref(): void;
    unref(): void;
    getChannelzRef(): SubchannelRef;
<<<<<<< HEAD
    isHealthy(): boolean;
    addHealthStateWatcher(listener: HealthListener): void;
    removeHealthStateWatcher(listener: HealthListener): void;
=======
>>>>>>> ef326e5cf5f78addbb22f4e968c863fa7a1af5f4
    /**
     * If this is a wrapper, return the wrapped subchannel, otherwise return this
     */
    getRealSubchannel(): Subchannel;
    /**
     * Returns true if this and other both proxy the same underlying subchannel.
     * Can be used instead of directly accessing getRealSubchannel to allow mocks
     * to avoid implementing getRealSubchannel
     */
    realSubchannelEquals(other: SubchannelInterface): boolean;
}
export declare abstract class BaseSubchannelWrapper implements SubchannelInterface {
    protected child: SubchannelInterface;
<<<<<<< HEAD
    private healthy;
    private healthListeners;
    constructor(child: SubchannelInterface);
    private updateHealthListeners;
=======
    constructor(child: SubchannelInterface);
>>>>>>> ef326e5cf5f78addbb22f4e968c863fa7a1af5f4
    getConnectivityState(): ConnectivityState;
    addConnectivityStateListener(listener: ConnectivityStateListener): void;
    removeConnectivityStateListener(listener: ConnectivityStateListener): void;
    startConnecting(): void;
    getAddress(): string;
    throttleKeepalive(newKeepaliveTime: number): void;
    ref(): void;
    unref(): void;
    getChannelzRef(): SubchannelRef;
<<<<<<< HEAD
    isHealthy(): boolean;
    addHealthStateWatcher(listener: HealthListener): void;
    removeHealthStateWatcher(listener: HealthListener): void;
    protected setHealthy(healthy: boolean): void;
=======
>>>>>>> ef326e5cf5f78addbb22f4e968c863fa7a1af5f4
    getRealSubchannel(): Subchannel;
    realSubchannelEquals(other: SubchannelInterface): boolean;
}
